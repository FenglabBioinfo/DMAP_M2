#! /usr/bin/perl

=head1 Description

  A robust and rapid candidate gene mapping pipeline based on M2 populations.
  
=head1 Version

  Author: Zhou Huangkai, hkzhou@genedenovo.com
  Author: Tang Kuanqiang, tangkuanqiang@iga.cas.cn
  Version: 1.0, Date: 2020-12-15

=cut

use utf8;
use strict;
use warnings;
use 5.16.0;
use List::Util qw(sum);
use Getopt::Long;
use Cwd 'abs_path';
use Thread;

&main();
sub main{
	my %opts = &Help();
	my ($vcf,$fai,$win,$step,$out,$mutant,$wild)=($opts{f},$opts{i},$opts{w},$opts{s},$opts{o},$opts{m},$opts{n});
	my (@vcf_bulk_variation,@vcf_filtered_step1,%hash_fai,%hash_fai_2,@array_chr_name,%hash_index_out,%hash_index,%hash_win,%hash_index_win);
	@vcf_bulk_variation = &get_bulk_variation($vcf,$mutant,$wild);
	if($opts{"c"}){
		@vcf_filtered_step1=&filter_step1(\@vcf_bulk_variation,$opts{"c"});
	}else{
		@vcf_filtered_step1=@vcf_bulk_variation;
	}
	&get_fai($fai,\%hash_fai,\%hash_fai_2,\@array_chr_name);
	%hash_index=&filter_step2(\@vcf_filtered_step1,\%hash_fai,\%hash_index_out,$out);
	if($opts{"l"}){
		%hash_index_win=&slid_snp(\%hash_index,$opts{"l"});
	}else{
		%hash_win=&get_win(\%hash_fai,$win,$step);
		%hash_index_win=&slid_win(\%hash_index,\%hash_win,$win,$step);
	}
	&create_Rscript(\%hash_index_win,\%hash_index,\@array_chr_name,\%hash_fai,\%hash_fai_2,$out,$fai);
	&plot($out);
	if($opts{"a"}){
		&print_out_table_annotation(\%hash_index_out,$out,$opts{"a"});
	}else{
		&print_out_table(\%hash_index_out,$out);
	}
}

sub Help{
	my %opts;
	my $usage = <<"USAGE";
Usage:
	perl $0 --vcf <vcf> --index <chrome_length>  --BulkMut <string> --BulkWild <string> --win <int>
	or
	perl $0 --vcf <vcf> --index <chrome_length>  --BulkMut <string> --BulkWild <string> --slideSNP <int>
Parameterï¼š
	--vcf/-f	input file of VCF type
	--index/-i	Chrome length which can generated by samtools software. The first column was the chromosome name, and the second column was the total length of the chromosome.
	--BulkMut/-m	Mutant bulk name in input file
	--BulkWild/-n	Wild bulk name in input file 
	--win/-w	Slide window, default 1000000
	--background_varation/-c	The VCF type file including the common variation
	--annotataion/-a	The annotation file from ANNOVAR software
	--slideSNP/l	The number of SNP in one window.
	--help/-h	Help	
Example:
	1.Slide window by predefined SNP number:
	perl $0 --vcf ./Example/SNP.vcf.gz --index ./Example/gmx.fa.fai --BulkMut mutant --BulkWild wild --slideSNP 1 --out ./Example/out
	perl $0 --vcf ./Example/SNP.vcf.gz --index ./Example/gmx.fa.fai --BulkMut mutant --BulkWild wild --slideSNP 1 --out ./Example/out --background_varation ./Example/background.vcf.gz --annotataion ./Example/SNP.annot.xls
	
	2.Slide window by predefined window length:
	perl $0 --vcf ./Example/SNP.vcf.gz --index ./Example/gmx.fa.fai --BulkMut mutant --BulkWild wild --win 1000000 --out ./Example/out
	perl $0 --vcf ./Example/SNP.vcf.gz --index ./Example/gmx.fa.fai --BulkMut mutant --BulkWild wild --win 1000000 --out ./Example/out --background_varation ./Example/background.vcf.gz --annotataion ./Example/SNP.annot.xls
Note:
	The script was the core script of DMAP-M2 method. The index value of mutant and wild type bulk, delta index value and absoluted delta index value in each variation and window can be calculated. And the chart of index values of all chromosomes can be also plotted. The annotation file in the input parameter was optional. If the annotaion file exists, the out file will contain the annotion infomation.
Version: 
	Version 1.0, Date: 2020-12-15
Author:
	Zhou Huangkai, hkzhou\@genedenovo.com
	Tang Kuanqiang, tangkuanqiang\@iga.cas.cn
	
USAGE
	Getopt::Long::GetOptions('help|h'    => \$opts{"h"},
							'version|v'  => \$opts{"v"},
							'vcf|f=s'    => \$opts{"f"},
							'index|i=s'  => \$opts{"i"},
							'win|w:i'    => \$opts{"w"},
							'step|s:i'   => \$opts{"s"},
							'out|o:s'    => \$opts{"o"},
							'background_varation|c:s' => \$opts{"c"},
							'BulkMut|m:s'     => \$opts{"m"},
							'BulkWild|n:s'    => \$opts{"n"},
							'annotataion|a:s' => \$opts{"a"},
							'slideSNP|l:i'    => \$opts{"l"});
	die $usage if($opts{"h"} || $opts{"v"});
	die $usage if(!$opts{"f"} || !$opts{"i"});
	die $usage if(!$opts{"m"} || !$opts{"n"});
	die "$opts{f} or $opts{i} doesn't exist!" if( !(-e $opts{"f"}) || !(-e $opts{"i"}));
	$opts{"w"} ||= 1000000;
	$opts{"s"} ||= $opts{"w"}/10;
	$opts{"o"}? (mkdir $opts{"o"}) : ($opts{"o"}= "./");
	$opts{"o"} = abs_path($opts{"o"});
	$opts{"f"} = abs_path($opts{"f"});
	$opts{"i"} = abs_path($opts{"i"});
	$opts{"c"} = abs_path($opts{"c"}) if($opts{"c"});
	$opts{"a"} = abs_path($opts{"a"}) if($opts{"a"});
	return %opts;
}

sub slid_snp{
	my ($hash_index,$snpcount)=@_;
	my %hash_index_win;
	foreach my $chr (sort keys %{$hash_index}){
		my @pos= sort {$a<=>$b} keys %{$$hash_index{$chr}};
		for(my $i=0;$i<@pos;$i+=$snpcount){
			my ($sum_pos,$count_pos,$average_pos,@index_slide)=(0,0,0,0);
			for(my $j=$i;($j<$i+$snpcount && $j<@pos);$j++){
				$sum_pos += $pos[$j]; $count_pos++;	
				my @index_pos=@{$$hash_index{$chr}{$pos[$j]}};
				for(my $k=0;$k<@index_pos;$k++){
					$index_slide[$k] += $index_pos[$k];
				}
			}
			for(my $k=0;$k<@index_slide;$k++){
				$index_slide[$k] = sprintf("%.6f",$index_slide[$k]/$count_pos);
			}
			$average_pos=sprintf("%.1f",$sum_pos/$count_pos);
			@{$hash_index_win{$chr}{$average_pos}}=@index_slide;
		}
	}
	return %hash_index_win;
}

sub print_out_table{
	my ($hash_index_out,$out)=@_;
	open F,">$out/variation_info.txt" or die $!;
	say F "#CHROM\tPOS\tREF\tALT\tBulk_Mutant_read_ref|alt\tBulk_Wild_read_ref|alt\tBulk_Mutant_index_ref\tBulk_Mutant_index\tBulk_Wild_index\tdelta_index\tABS_delta_index";
	foreach my $chr (sort keys %{$hash_index_out}){
		foreach my $pos (sort {$a<=>$b} keys %{$$hash_index_out{$chr}}){
			say F join("\t",($chr,$pos,@{$$hash_index_out{$chr}{$pos}}));
		}
	}
	close F;
}

sub print_out_table_annotation{
	my ($hash_index_out,$out,$annotation_file)=@_;
	open F,$annotation_file or die $!;
	my %hash_tmp;
	while(<F>){
		chomp;
		my @tmp=split /\t/;
		my ($chr,$pos)=@tmp[0,1];
		push @{$hash_tmp{$chr}{$pos}},@tmp[12..15] if(@tmp>13);
	}
	close F;
	open F,">$out/variation_info_annotation.txt" or die $!;
	say F "#CHROM\tPOS\tREF\tALT\tBulk_Mutant_read_ref|alt\tBulk_Wild_read_ref|alt\tBulk_Mutant_index_ref\tBulk_Mutant_index\tBulk_Wild_index\tdelta_index\tABS_delta_index\tstructure_type\tstructure_gene\tfunction_type\tfunction_gene";
	foreach my $chr (sort keys %{$hash_index_out}){
		foreach my $pos (sort {$a<=>$b} keys %{$$hash_index_out{$chr}}){
			if(exists $hash_tmp{$chr}{$pos}){
				say F join("\t",($chr,$pos,@{$$hash_index_out{$chr}{$pos}},@{$hash_tmp{$chr}{$pos}}));
			}else{
				say F join("\t",($chr,$pos,@{$$hash_index_out{$chr}{$pos}},"-","-","-","-"));
			}
		}
	}
	close F;
}

sub get_bulk_variation{
	my ($vcf,$mutant,$wild)=@_;
	my @vcf_bulk_variation;
    if($vcf =~ /.gz$/) {
		open F,"gzip -dc $vcf|" or die $!;
	}else{
		open F,$vcf or die $!;
	}
	my ($sub_mutant,$sub_wild)=(0,0);
	while(<F>){
		chomp;
		if(/^##/){
			push @vcf_bulk_variation,$_;
			next;
		}elsif(/^#CHROM/){
			my @head=split /\t/;
			for(my $i=9;$i<@head;$i++){
				if($head[$i] =~ /$mutant/){
					$sub_mutant=$i;
				}elsif($head[$i] =~ /$wild/){
					$sub_wild=$i;
				}
			}
			if($sub_mutant==0 || $sub_wild==0){
				die "The mutant bulk name or wild bulk name is wrong, please check it carefully";
			}
			push @vcf_bulk_variation,join("\t",(@head[0..8],$head[$sub_mutant],$head[$sub_wild]));
		}else{
			my @tmp=split /\t/;
			push @vcf_bulk_variation,join("\t",(@tmp[0..8],$tmp[$sub_mutant],$tmp[$sub_wild]));
		}
	}
	close F;
	return @vcf_bulk_variation;
}

sub filter_step1{
	my ($vcf_bulk_variation,$common_variation)=@_;
	my (@vcf_filtered_step1,%hash_common_variation);
	if($common_variation =~ /.gz$/){
		open F,"gzip -dc $common_variation|" or die $!;
	}else{
		open F,$common_variation or die $!;
	}
	while(<F>){
		chomp;
		next if(/^#/);
		my ($chr,$loc,@tmp) = split;
		$hash_common_variation{$chr}{$loc}++;
	}
	close F;
	foreach my $line (@{$vcf_bulk_variation}){
		chomp $line;
		if($line=~/^#/){
			push @vcf_filtered_step1,$line;
		}else{
			my ($chr,$loc,@tmp) = split /\t/,$line;
			push @vcf_filtered_step1,$line unless(exists $hash_common_variation{$chr}{$loc});
		}
	}
	return @vcf_filtered_step1;
}

sub plot{
	my $out=$_[0];
	my @file=glob("$out/*_plot.R");
	my @threads;
	for(my $i=0;$i<@file;$i++){
		$threads[$i]=Thread->create(\&start_thread,$file[$i]);
	}
	foreach my $thread(@threads){
		$thread->join();
	}
	unlink (@file,"$out/index_all.tmp","$out/index_win.tmp","$out/SNP_filter_2.tsv","$out/SNP_filter_1.vcf");
}

sub start_thread{
	my $rscript=$_[0];
	system("Rscript $rscript");
}

sub create_Rscript{
	my ($hash_index_win,$hash_index,$array_chr_name,$hash_fai,$hash_fai_2,$out,$fai)=@_;
	open OUT_INDEX_WIN,">","$out\/index_win.tmp" or die $!;
	open OUT_INDEX_ALL,">","$out\/index_all.tmp" or die $!;
	open FAI,">","$out\/fai.tmp" or die $!;
	my $header=join("\t","Chromesome\tPosition\tTotalLength\tMIndex\tWIndex\tDindex\tABSDIndex");
	say OUT_INDEX_WIN $header;
	say OUT_INDEX_ALL $header;
	foreach my $chr (@{$array_chr_name}){
		foreach my $pos (sort {$a <=> $b} keys %{$$hash_index_win{$chr}}){
			say OUT_INDEX_WIN join("\t",($chr,$pos,$pos+$$hash_fai_2{$chr},@{$$hash_index_win{$chr}{$pos}}));
		}
		foreach my $pos (sort {$a <=> $b} keys %{$$hash_index{$chr}}){
			say OUT_INDEX_ALL join("\t",($chr,$pos,$pos+$$hash_fai_2{$chr},@{$$hash_index{$chr}{$pos}}));
		}
		say FAI join("\t",($chr,$$hash_fai{$chr},$$hash_fai_2{$chr}));
	}
	close OUT_INDEX_WIN; close OUT_INDEX_ALL; close FAI;
	my $R1=<<EOF;
setwd("$out"); library("ggplot2"); library("gridExtra"); library("Cairo"); library("Rmisc");
index_all<-read.table("$out/index_all.tmp",sep = "\t",header = T)
index_win<-read.table("$out/index_win.tmp",sep = "\t",header = T)
fai<-read.table("$out/fai.tmp",sep = "\t",row.names = 1,header = F)

p_theme<-theme_bw()+
  theme(#panel.grid = element_blank(),
    panel.background = element_blank(),
    panel.border = element_rect(color ="black", size=0.5, linetype="solid"), 
    axis.ticks.length=unit(-0.15, "cm"), 
    axis.text.x = element_text(margin=unit(c(0.5,0,0,0), "cm"),size = 8), 
    axis.text.y = element_text(margin=unit(c(0,0.5,0,0), "cm"),size = 8),
    axis.title.y = element_text(size = 10),
    axis.title.x = element_text(size = 10))
EOF
	my %R2;
	foreach my $chr (@{$array_chr_name}){
		$R2{$chr}=<<EOF;
print("$chr");
index_all_chr<-index_all[index_all\$Chromesome == "$chr",];
index_win_chr<-index_win[index_win\$Chromesome == "$chr",];

c1<-ggplot()+
geom_point(data = index_all_chr,aes(Position ,Dindex),colour="#00BA38",size=0.5)+
scale_y_continuous(limits = c(-1,1),breaks=seq(-1,1,0.5),expand=c(0,0))+
scale_x_continuous(limits = c(0,fai["$chr",1]), breaks = 10000000*0:10,labels = 10*0:10,expand=c(0,0))+
ylab("Delta index value")+xlab("")+
p_theme+theme(axis.title.x = element_text(hjust = 1))

c2<-ggplot()+
geom_point(data = index_all_chr,aes(Position ,ABSDIndex),colour="#00BA38",size=0.5)+
scale_y_continuous(limits = c(0,1),breaks=seq(-1,1,0.25),expand=c(0,0))+
scale_x_continuous(limits = c(0,fai["$chr",1]),breaks = 10000000*0:10,labels = 10*0:10,expand=c(0,0))+
ylab("Absolute value of delta index")+xlab("")+
p_theme+theme(axis.title.x = element_text(hjust = 1))

c3<-ggplot()+
geom_point(data = index_all_chr,aes(Position ,MIndex),colour="#00BA38",size=0.5)+
scale_y_continuous(limits = c(0,1),breaks=seq(-1,1,0.25),expand=c(0,0))+
scale_x_continuous(limits = c(0,fai["$chr",1]),breaks = 10000000*0:10,labels = 10*0:10,expand=c(0,0))+
ylab("Index value of mutant bulk")+xlab("")+
p_theme+theme(axis.title.x = element_text(hjust = 1))

c4<-ggplot()+
geom_point(data = index_all_chr,aes(Position ,WIndex),colour="#00BA38",size=0.5)+
scale_y_continuous(limits = c(0,1),breaks=seq(-1,1,0.25),expand=c(0,0))+
scale_x_continuous(limits = c(0,fai["$chr",1]),breaks = 10000000*0:10,labels = 10*0:10,expand=c(0,0))+
ylab("Index value of wild type bulk")+xlab(paste("$chr","(Mb)",sep = " "))+
p_theme+theme(axis.title.x = element_text(hjust = 1))
if(length(index_win_chr\$Position)>1){
	c1<-c1+geom_line(data = index_win_chr,aes(Position,Dindex),colour="#F8766D",size=0.5)
	c2<-c2+geom_line(data = index_win_chr,aes(Position,ABSDIndex),colour="#F8766D",size=0.5)
	c3<-c3+geom_line(data = index_win_chr,aes(Position,MIndex),colour="#F8766D",size=0.5)
	c4<-c4+geom_line(data = index_win_chr,aes(Position,WIndex),colour="#F8766D",size=0.5)
}

CairoTIFF(filename = paste("$out/","$chr","_index.tiff",sep = ""),width = 3000,height = 2500,pointsize = 12,dpi=300 )
multiplot(c1,c2,c3,c4,cols=1)
dev.off()
EOF
	}
	$R2{"all"}=<<EOF;
cll<-as.numeric(gsub(pattern = "[A-z]",replacement = "",x=index_all\$Chromesome,perl=T)) %% 2
cl<-as.vector(factor(cll,levels = c(0,1),labels =c("#00BA38","#619CFF")))

p1<-ggplot()+
  geom_point(data = index_all,aes(TotalLength,Dindex),colour=cl,size=0.5)+
  geom_line(data = index_win,aes(TotalLength,Dindex),colour="#F8766D",size=0.5)+
  scale_y_continuous(limits = c(-1,1),breaks=seq(-1,1,0.5),expand=c(0,0))+
  scale_x_continuous(limits = c(0,sum(fai[,1])),breaks = fai\$V3+(fai\$V2/2),
					labels = row.names(fai),expand=c(0,0))+
  ylab("Delta index value")+xlab("")+p_theme

p2<-ggplot()+
  geom_point(data = index_all,aes(TotalLength,ABSDIndex),color=cl,size=0.5)+
  geom_line(data = index_win,aes(TotalLength,ABSDIndex),color="#F8766D",size=0.5)+
  scale_y_continuous(limits = c(0,1),breaks=seq(-1,1,0.25),expand=c(0,0))+
  scale_x_continuous(limits = c(0,sum(fai[,1])),breaks = fai\$V3+(fai\$V2/2),
					labels = row.names(fai),expand=c(0,0))+
  ylab("Absolute value of delta index")+xlab("")+p_theme

p3<-ggplot()+
  geom_point(data = index_all,aes(TotalLength,MIndex),color=cl,size=0.5)+
  geom_line(data = index_win,aes(TotalLength,MIndex),color="#F8766D",size=0.5)+
  scale_y_continuous(limits = c(0,1),breaks=seq(-1,1,0.25),expand=c(0,0))+
  scale_x_continuous(limits = c(0,sum(fai[,1])),breaks = fai\$V3+(fai\$V2/2),
					labels = row.names(fai),expand=c(0,0))+
  ylab("Index value of mutant bulk")+xlab("")+p_theme

p4<-ggplot()+
  geom_point(data = index_all,aes(TotalLength,WIndex),color=cl,size=0.5)+
  geom_line(data = index_win,aes(TotalLength,WIndex),color="#F8766D",size=0.5)+
  scale_y_continuous(limits = c(0,1),breaks=seq(-1,1,0.25),expand=c(0,0))+
  scale_x_continuous(limits = c(0,sum(fai[,1])),breaks = fai\$V3+(fai\$V2/2),
					labels = row.names(fai),expand=c(0,0))+
  ylab("Index value of wild type bulk")+xlab("")+p_theme

CairoTIFF(filename = "${out}/all_index.tiff",width = 3000,height = 2500,pointsize = 12,dpi=300 )
multiplot(p1,p2,p3,p4,cols=1)
dev.off()
EOF
	foreach my $chr (sort keys %R2){
		open OUT_Rscript,">","$out/${chr}_plot.R" or die $!;
		my $say_out = join("\n",($R1,$R2{$chr}));
		say OUT_Rscript $say_out;
		close OUT_Rscript;
	}
}

sub slid_win{
	my ($hash_index,$hash_win,$win,$step)=@_;
	my (%hash_index_win,%hash_index_win_count);
	foreach my $chr (sort keys %{$hash_win}){
		my @pos_wins   = sort {$a <=> $b} keys %{$$hash_win{$chr}};
		my @pos_indexs = sort {$a <=> $b} keys %{$$hash_index{$chr}};
		my $flag=0;
		for(my $i=0;$i<@pos_wins;$i++){
			my $pos_win=$pos_wins[$i];
			my ($start,$end)=@{$$hash_win{$chr}{$pos_win}};
			for(my $j=$flag;$j<@pos_indexs;$j++){
				my $pos_index=$pos_indexs[$j];
				if($pos_index < $start){
					$flag=$j;
				}elsif($pos_index>=$start && $pos_index<$end){
					$hash_index_win_count{$chr}{$pos_win}++;
					for(my $k=0;$k<@{$$hash_index{$chr}{$pos_index}};$k++){
						$hash_index_win{$chr}{$pos_win}[$k] += $$hash_index{$chr}{$pos_index}[$k];
					}
				}elsif($pos_index >= $end){
					last;
				}
			}
			if(exists $hash_index_win{$chr}{$pos_win}){
				for(my $i=0;$i<@{$hash_index_win{$chr}{$pos_win}};$i++){
					$hash_index_win{$chr}{$pos_win}[$i] /= $hash_index_win_count{$chr}{$pos_win};
				}
			}
		}
	}
	return %hash_index_win;
}

sub get_win{
	my ($hash_fai,$win,$step)=@_;
	my %hash_win;
	foreach my $chr (sort keys %{$hash_fai}){
		my $len=$$hash_fai{$chr};
		for(my $i=1;$i<=$len;$i+=$step){
			if(($i+$win)>$len){
				my $pos = ($i+$len)/2;
				push @{$hash_win{$chr}{$pos}},($i,$len);
				last;
			}else{
				my $pos = ($i+$i+$win)/2;
				push @{$hash_win{$chr}{$pos}},($i,$i+$win);
			}
		}
	}
	return %hash_win;
}

sub get_fai{
	my ($file_name,$hash_fai,$hash_fai_2,$chr_name)=@_;
	open F1,$file_name or die $!;
	my $total_length=1;
	while(<F1>){
		next if(/^#|chrome_name/);
		chomp;
		my ($chr,$length,$length_all)=split /\t/,$_;
		$$hash_fai{$chr}=$length;
		$$hash_fai_2{$chr}=$total_length;
		$total_length+=$length;
		push @{$chr_name},$chr;
	}
	close F1;
}

sub filter_step2{
	my ($vcf_filtered,$hash_fai,$hash_index_out,$out)=@_;
	my %hash_index;
	open F2,">","$out\/SNP_filter_1.vcf" or die $!;
	open F3,">","$out\/SNP_filter_2.tsv" or die $!;
	say F3 join("\t",("Chromesome","Position","GeneTypeRef","GeneTypeMut","ReadDepthM","ReadDepthW","IndexM","IndexW","DeltaIndex","ABSDeltaINdex"));
	foreach my $line (@{$vcf_filtered}){
		if($line =~ /^#/){
			say F2 $line;
		}else{
			my @tmp=split /\t/,$line;
			my ($chr,$pos,$ref,$mut,$M,$W) = @tmp[0,1,3,4,9,10];
			next unless(exists $$hash_fai{$chr});
			next if(($ref =~ /,/) || ($mut =~ /,/));	# keep only biallen
			next if(length($ref)>1 || length($mut)>1);	# filter indel
			next if($M !~ /,/ || $W !~ /,/);			# filter the site which have no read.
			my @MM = split /:/,$M;
			my @WW = split /:/,$W;
			my ($depth_M_ref,$depth_M_mut) = split /,/,$MM[1];
			my ($depth_W_ref,$depth_W_mut) = split /,/,$WW[1];
			my ($depth_W_all,$depth_M_all) = (($depth_W_ref+$depth_W_mut),($depth_M_ref+$depth_M_mut));
			next if($depth_W_all<7 && $depth_M_all<7);	# filter by depth
			my ($index_M,$index_W)=(sprintf("%.6f",$depth_M_mut/$depth_M_all),sprintf("%.6f",$depth_W_mut/$depth_W_all));
			# Discard the SNP which index of two bulk were larger than 0.7 or less than 0.3 at the same time.
			next if(($index_M>0.7 && $index_W>0.7) || ($index_M<0.3 && $index_W<0.3)); 
			next if($index_M==0); # Discard the SNP which index of mutant bulk was equal to zero.
			my ($delta_index,$delta_index_abs)=(sprintf("%.6f",($index_M-$index_W)),sprintf("%.6f",abs($index_M-$index_W)));
			say F2 $line;
			say F3 join("\t",($chr,$pos,$ref,$mut,"$depth_M_ref\|$depth_M_mut","$depth_W_ref\|$depth_W_mut",$index_M,$index_W,$delta_index,$delta_index_abs));
			push @{$hash_index{$chr}{$pos}},($index_M,$index_W,$delta_index,$delta_index_abs);
			push @{$$hash_index_out{$chr}{$pos}},($ref,$mut,"$depth_M_ref\|$depth_M_mut","$depth_W_ref\|$depth_W_mut",$index_M,$index_W,$delta_index,$delta_index_abs);
		}
	}
	close F2; close F3;
	return %hash_index;
}
